#!/bin/bash
set -eu

# Root Check
if [[ "$(id -u)" == "0" ]]; then
	echo "Error: Cannot run 'pkg' command as root"
	exit 1
fi

# Setup TERMUX_APP_PACKAGE_MANAGER
# shellcheck source=/dev/null
source "@TERMUX_PREFIX@/bin/termux-setup-package-manager" || exit 1

MIRROR_BASE_DIR="@TERMUX_PREFIX@/etc/termux/mirrors"
DEFAULT_REPO="${MIRROR_BASE_DIR}/default"
UP_TO_DATE_THRESHOLD=21600 # 6 hours

show_help() {
	local cache_size
	local cache_dir=""
	if [ "$TERMUX_APP_PACKAGE_MANAGER" = "apt" ]; then
		cache_dir="@TERMUX_CACHE_DIR@/apt/archives"
	elif [ "$TERMUX_APP_PACKAGE_MANAGER" = "pacman" ]; then
		cache_dir="@TERMUX_PREFIX@/var/cache/pacman/pkg"
	fi
	cache_size=$(du -sh "$cache_dir" 2>/dev/null | cut -f1)

	echo 'Usage: pkg [--check-mirror] [-u|--up-to-date-mirror] command [arguments]'
	echo
	echo "A tool for managing $TERMUX_APP_PACKAGE_MANAGER packages."
	echo '  --check-mirror forces a re-check of availability of mirrors'
	echo
	echo 'Commands:'
	echo
	echo "  autoclean            - Remove all outdated packages from $TERMUX_APP_PACKAGE_MANAGER"
	echo '                         cache.'
	echo
	echo "  clean                - Remove all packages from $TERMUX_APP_PACKAGE_MANAGER cache."
	[ -n "$cache_size" ] &&
	echo "                         Using $cache_size now."
	echo
	echo '  files <packages>     - Show all files installed by packages.'
	echo
	echo '  install <packages>   - Install specified packages.'
	echo
	echo '  list-all             - List all packages available in repositories.'
	echo
	echo '  list-installed       - List installed packages.'
	echo
	echo '  reinstall <packages> - Reinstall specified installed packages at the'
	echo '                         latest version.'
	echo
	echo '  search <query>       - Search package by query, for example by name or'
	echo '                         description part.'
	echo
	echo '  show <packages>      - Show basic metadata, such as dependencies.'
	echo
	echo '  uninstall <packages> - Uninstall specified packages. Configuration files'
	echo '                         will be left intact.'
	echo
	echo '  upgrade              - Upgrade all installed packages to the latest'
	echo '                         version.'
	echo
	echo "  update               - Update $TERMUX_APP_PACKAGE_MANAGER databases from configured"
	echo '                         repositories.'
	echo
	exit 1
}

# Converts seconds to human-readable format.
# Example: `sec_to_human_readable 12345` => 3h 25m 45s
sec_to_human_readable() {
	echo "$(($1/86400))d $(($1%86400/3600))h $(($1%3600/60))m $(($1%60))s" | sed -E 's/^0d //g; s/(^| )0h//g; s/(^| )0m//g; s/(^| )0s$//g'
}

get_weighted_mirrors() ( # This function must run in a subshell
	local timeout="${1}"
	shift # all other args are mirrors

	local argv=("$@") # bash can not iterate function argv directly
	local has_default="false" wait_default="false" default_date="" default_ts="" now=""
	now="$(date "+%s")"

	local i is_ok content url line mirrorname weight header difference lines=() mirrors=() args=(
		"--silent"
		"--location"
		"--range" "0-200"
		"--user-agent" "Termux-PKG/2.0 mirror-checker (termux-tools @PACKAGE_VERSION@) Termux (@TERMUX_APP_PACKAGE@; install-prefix:@TERMUX_PREFIX@)"
		"--parallel" "--parallel-immediate" "--parallel-max" "100"
		"--max-time" "$timeout"
		"-w" "%{exitcode}\r %{errormsg}\r%{http_code}\r%{url}\r%{filename_effective}\n"
	)

	# unfortunately there is no way to create absolutely anonymous files or pipes in bash to be reused in curl
	# so we create temporary folder where curl will be able to put its files
	# and scheduling cleanup after function finishes.
	cd "$(mktemp -d pkg.XXXXXXXXXX)"
	coproc { read -r || :; rm -rf "$(pwd)"; } # removes current directory as soon as current subshell finishes

	for ((i=0; i<$#; i++)); do
		IFS=$'\r' read -r url weight < <(get_mirror_url "${argv[$i]}")
		# Part after # symbol is not being sent to server and can be reused locally
		url="$url/dists/stable/Release#${weight}|${argv[$i]}"
		if (( $# != 1 && i == 0 )) && [[ "${argv[$i]}" == "${DEFAULT_REPO}" ]]; then
			url="$url|default"
			wait_default="true"
		fi
		args+=("-o" "Release_${i}" "${url}")
	done

	# In the case if we use mirror group we still should obtain default mirror data
	# to check if mirrors we are about to pick are not outdated.
	# But we will set weight=0 to avoid picking it.
	if [[ "$#" -gt 1 && "$wait_default" != "true" ]]; then
		IFS=$'\r' read -r url _ < <(get_mirror_url "${DEFAULT_REPO}")
		args+=("-o" "Release_default" "$url/dists/stable/Release#0|0|default")
		wait_default="true"
	fi

	while read -r line; do
		if [[ "$wait_default" == "true" && "$has_default" == "false" ]]; then
			if [[ "$line" != *"|default"* ]]; then
				# we did not get default mirror results, delay processing
				# we are required to have default mirror timestamp for validating other mirrors
				lines+=("$line")
				continue
			else
				has_default="true"
				line="${line//|default/}"
				IFS=$'\r' read -r exit_code _ http_code url filename _ <<< "${line}" || { echo "failed to read line $line" >&2; continue; }
				# default mirror is always valid, we should only extract timestamp
				if [[ "$exit_code" == "0" && "$http_code" == "206" && -f "$filename" ]] && [[ $'\n'"$(<"$filename")"$'\n' =~ $'\nDate: '([^$'\n']*)$'\n' ]]; then
					# reset date in the case if we can not parse it, it is useless
					[[ -n "${BASH_REMATCH[1]}" ]] && default_date="${BASH_REMATCH[1]}" default_ts="$(date -d "${BASH_REMATCH[1]}" "+%s")" || default_date="" default_ts=""
					[[ -n "$default_date" ]] && echo "Default mirror date is ${default_date}" >&2
				fi
			fi
		fi
		for line in "$line" "${lines[@]}"; do
			IFS=$'\r' read -r exit_code error_msg http_code url filename _ <<< "${line}" || { echo "failed to read line $line" >&2; continue; }

			# split url and weight we concatenated in curl write-out
			weight="${url#*#}"
			url="${url%%/dists/stable/Release#*}"
			mirrorname="${weight#*|}"
			weight="${weight%%|*}"
			(( weight > 0 )) || continue

			# shellcheck disable=SC2015
			header="[*] $( (( $# > 1 )) && echo "($weight) " || : )${url}:"
			if (( exit_code == 28 )); then
				echo "$header timeout" >&2
			elif (( exit_code != 0 )); then
				echo "$header bad (${error_msg:1})" >&2
			elif (( http_code != 200 && http_code != 206 )); then
				echo "$header bad (HTTP error $http_code)" >&2
			else
				is_ok=0 last_modified="" timestamp=""
				content="$(<"$filename")"

				# check if release file has last modification date, correct origin and current arch.
				if [[ $'\n'"${content}"$'\n' =~ $'\nDate: '([^$'\n']*)$'\n' \
						&& $'\n'"${content}"$'\n' == *$'\nOrigin: termux-main stable\n'* \
						&& $'\n'"${content}"$'\n' == *$'\nArchitectures:'?([^$'\n']*)*@TERMUX_ARCH@?([^$'\n']*)$'\n'* ]]; then
					last_modified="${BASH_REMATCH[1]}"
				else
					echo "$header invalid" >&2
					continue
				fi

				if [[ -z "$default_ts" || "$default_date" == "$last_modified" ]]; then
					# if default mirror last modified time is unknown we skip the check
					# same applies with last modified time matches
					is_ok=1
				elif [[ -z "$last_modified" ]] || ! timestamp="$(date -d "$last_modified" "+%s")"; then
					echo "$header invalid timestamp '${last_modified-null}' '${timestamp-null}'" >&2
					continue
				fi

				if (( is_ok != 1 )); then
					difference="$(( default_ts - ${timestamp-0} ))"
					if (( timestamp > now )); then
						echo "$header invalid timestamp (date in the future?)" >&2
						continue
					elif (( difference < 0 )); then
						echo "$header superdated (by $(sec_to_human_readable $(( -difference )) ))" >&2
						continue
					elif (( difference > UP_TO_DATE_THRESHOLD )); then
						echo "$header outdated (by $(sec_to_human_readable $(( difference - UP_TO_DATE_THRESHOLD )) ))" >&2
						continue
					fi
				fi
				echo "$header $( (( $# > 1 && is_ok == 1 )) && echo up-to-date || echo ok )" >&2

				# And now print weighted value of the mirror, repeat the line $weight times
				for ((i=0; i<weight; i++)); do
					printf "%s\n" "$mirrorname"
				done
			fi
		done
		# reset processed lines
		lines=()
	done < <(curl "${args[@]}" || :)
)

check_single_mirror() {
	# Special case, we should check single mirror
	[[ -n "$(get_weighted_mirrors 5 <(printf "MAIN=%s\nX11=%s\nROOT=%s\nWEIGHT=1\n" "$1" "$1" "$1"))" ]]
}

check_command() {
	local command="$1"

	local errors
	if ! errors="$("$@" 2>&1 1>/dev/null)"; then
		echo "$errors" 1>&2
		echo "Failed to run the '$command' command." 1>&2
		if [[ "$errors" == *"CANNOT LINK EXECUTABLE"* ]]; then
			echo -n "To fix the '$command' command, manually upgrade all packages by running: " 1>&2
			case "$TERMUX_APP_PACKAGE_MANAGER" in
				apt) echo "\`apt update && apt full-upgrade\`" 1>&2;;
				pacman) echo "\`pacman -Syu\`" 1>&2;;
			esac
		fi
		exit 1
	fi
}

replace_uris_in_file() {
	local uris="$1" file="$2"
	uris="${uris//[\\]/\\\\}" # Escape `\`.
	uris="${uris//[\/]/\\\/}" # Escape `/`.
	uris="${uris//[&]/\\\&}"  # Escape `&`.
	sed -i -e "s|URIs:.*|URIs: ${uris}|" "$file"
}

has_repo() {
	# Check if root-repo or x11-repo are installed
	repo="$1"

	if [[ -f "@TERMUX_PREFIX@/etc/apt/sources.list.d/$repo.sources" ]]; then
		echo deb822
	elif [[ -f "@TERMUX_PREFIX@/etc/apt/sources.list.d/$repo.list" ]]; then
		echo legacy
	fi
}

unset_mirror_variables() {
	unset MAIN
	unset X11
	unset ROOT
	unset WEIGHT
}

get_mirror_url() {
	local -r _mirror="$1"

	unset_mirror_variables
	# shellcheck source=/dev/null
	source "$_mirror"

	if [[ -z "${MAIN:-}" ]]; then
		echo "Warn: Ignoring mirror '$_mirror' without main channel url" >&2
		return 0
	elif [[ ! "${MAIN:-}" =~ ^https?://[^[:space:]]+$ ]]; then
		echo "Warn: Ignoring mirror '$_mirror' with invalid main channel url '${MAIN:-}'" >&2
		return 0
	fi

	if [[ -n "$HAS_X11_REPO" ]]; then
		if [[ -z "${X11:-}" ]]; then
			echo "Warn: Ignoring mirror '$_mirror' without x11 channel url" >&2
			return 0
		elif [[ ! "${X11:-}" =~ ^https?://[^[:space:]]+$ ]]; then
			echo "Warn: Ignoring mirror '$_mirror' with invalid x11 channel url '${X11:-}'" >&2
			return 0
		fi
	fi

	if [[ -n "$HAS_ROOT_REPO" ]]; then
		if [[ -z "${ROOT:-}" ]]; then
			echo "Warn: Ignoring mirror '$_mirror' without root channel url" >&2
			return 0
		elif [[ ! "${ROOT:-}" =~ ^https?://[^[:space:]]+$ ]]; then
			echo "Warn: Ignoring mirror '$_mirror' with invalid root channel url '${ROOT:-}'" >&2
			return 0
		fi
	fi

	if [[ ! "${WEIGHT:-}" =~ ^[0-9]+$ ]]; then
		echo "Warn: Ignoring mirror '$_mirror' with invalid weight '${WEIGHT:-}'" >&2
		return 0
	fi

	echo "${MAIN%/}"$'\r'"${WEIGHT}"
}

select_mirror() {
	local current_mirror
	if [[ -f "@TERMUX_PREFIX@/etc/apt/sources.list.d/main.sources" ]]; then
		current_mirror=$(grep -m1 -Po '^[[:space:]]*URIs:[[:space:]]+\K(https?://[^ ]+)' "@TERMUX_PREFIX@/etc/apt/sources.list.d/main.sources" || :)
	elif [[ -f "@TERMUX_PREFIX@/etc/apt/sources.list" ]]; then
		current_mirror=$(grep -m1 -Po '^[[:space:]]*deb[[:space:]]+\K(https?://[^ ]+)' "@TERMUX_PREFIX@/etc/apt/sources.list" || :)
	fi

	# Do not update mirror if $TERMUX_PKG_NO_MIRROR_SELECT was set.
	if [[ -n "${TERMUX_PKG_NO_MIRROR_SELECT-}" && -n "$current_mirror" ]]; then
		return
	fi

	if [[ -d "@TERMUX_PREFIX@/etc/termux/chosen_mirrors" ]]; then
		# Mirror group selected
		# shellcheck disable=SC2207
		mirrors=($(find "@TERMUX_PREFIX@/etc/termux/chosen_mirrors/" -type f ! -name "*\.dpkg-old" ! -name "*\.dpkg-new" ! -name "*~"))
	elif [[ -f "@TERMUX_PREFIX@/etc/termux/chosen_mirrors" ]]; then
		# Single mirror selected
		mirrors=("$(realpath "@TERMUX_PREFIX@/etc/termux/chosen_mirrors")")
	elif [[ -L "@TERMUX_PREFIX@/etc/termux/chosen_mirrors" ]]; then
		# Broken symlink, use all mirrors
		mirrors=("${DEFAULT_REPO}")
		# shellcheck disable=SC2207
		mirrors+=($(find "${MIRROR_BASE_DIR}"/{asia,chinese_mainland,europe,north_america,oceania,russia}/ -type f ! -name "*\.dpkg-old" ! -name "*\.dpkg-new" ! -name "*~"))
	else
		echo "No mirror or mirror group selected. You might want to select one by running 'termux-change-repo'"
		mirrors=("${DEFAULT_REPO}")
		# shellcheck disable=SC2207
		mirrors+=($(find ${MIRROR_BASE_DIR}/{asia,chinese_mainland,europe,north_america,oceania,russia}/ -type f ! -name "*\.dpkg-old" ! -name "*\.dpkg-new" ! -name "*~"))
	fi

	# Ensure `curl` can execute, otherwise all mirror checks will fail with `bad`.
	check_command curl --version

	# Mirrors are rotated if 6 hours timeout has been passed or mirror is no longer accessible.
	local pkgcache="@TERMUX_CACHE_DIR@/apt/pkgcache.bin"
	if [[ -n "$(find "$pkgcache" -mmin -360 -type f -print)" && "$force_check_mirror" == "false" && -n "$current_mirror" ]]; then
		echo "Checking availability of current mirror:"
		check_single_mirror "$current_mirror" && return
	fi

	# Test mirror availability, remove unaccessible mirrors and pick random up-to-date one
	local selected_mirror=""
	echo "Testing the available mirrors:"
	selected_mirror="$(get_weighted_mirrors 5 "${mirrors[@]}" | shuf -n1)" 2>&1
	if [[ -z "$selected_mirror" ]]; then
		# Should not happen unless there is some issue with
		# the script, or the mirror files
		echo "Error: None of the mirrors are accessible"
		exit 1
	fi

	# shellcheck source=/dev/null
	echo "Picking mirror: $(source "$selected_mirror" 2>/dev/null; echo "${MAIN-$selected_mirror}")"

	(
		unset_mirror_variables
		# shellcheck source=/dev/null
		source "$selected_mirror"

		case "$(has_repo main)" in
			'deb822') replace_uris_in_file "$MAIN" "@TERMUX_PREFIX@/etc/apt/sources.list.d/main.sources";;
			# There should always be a main repo, so fallback to
			# creating sources.list if the `main.sources` file is missing
			*) echo "deb $MAIN stable main" > "@TERMUX_PREFIX@/etc/apt/sources.list";;
		esac

		case "${HAS_X11_REPO:-}" in
			'deb822') replace_uris_in_file "$X11" "@TERMUX_PREFIX@/etc/apt/sources.list.d/x11.sources";;
			'legacy') echo "deb $X11 x11 main" > "@TERMUX_PREFIX@/etc/apt/sources.list.d/x11.list";;
		esac

		case "${HAS_ROOT_REPO:-}" in
			'deb822') replace_uris_in_file "$ROOT" "@TERMUX_PREFIX@/etc/apt/sources.list.d/root.sources";;
			'legacy') echo "deb $ROOT root stable" > "@TERMUX_PREFIX@/etc/apt/sources.list.d/root.list";;
		esac
	)
}

update_apt_cache() {
	local list_prefix="" sources_file="" metadata_file=""
	if [[ -f "@TERMUX_PREFIX@/etc/apt/sources.list.d/main.sources" ]]; then
		sources_file="@TERMUX_PREFIX@/etc/apt/sources.list.d/main.sources"
		read -r list_prefix < <(sed -nE 's|^\s*URIs:\s+https?://(.+[^/])/?$|\1|p' "$sources_file") || :
	elif [[ -f "@TERMUX_PREFIX@/etc/apt/sources.list" ]]; then
		sources_file="@TERMUX_PREFIX@/etc/apt/sources.list"
		read -r list_prefix < <(sed -nE 's|^\s*deb\s+https?://(.+[^/])/?\s+stable\s+main$|\1|p' "$sources_file") || :
	else
		echo "ERROR: Main deb source file is missing."
		exit 1
	fi

	metadata_file="@TERMUX_PREFIX@/var/lib/apt/lists/${list_prefix//\//_}_dists_stable_main_binary-@TERMUX_ARCH@_Packages"

	# No primary repositories configured or no downloaded metadata cache or pkgcache is missing or outdated
	if [[ -z "$list_prefix" || ! -e "$metadata_file" || -z "$(find "@TERMUX_CACHE_DIR@/apt/pkgcache.bin" -type f -mmin -120 -newer "$sources_file" -print)" ]]; then
		apt update
	fi
}

force_check_mirror=false
if [[ "${1-}" == "--check-mirror" ]]; then
	force_check_mirror=true
	shift 1
fi

if [[ "${1-}" == "-u" || "${1-}" == "--up-to-date-mirror" ]]; then
	UP_TO_DATE_THRESHOLD=0 # Use only the most up-to-date mirror, ignoring the threshold
	shift 1
fi

if [[ "$#" = "0" || "$1" == "h"* ]]; then
	show_help
fi

CMD="$1"
shift 1
ERROR=false

HAS_X11_REPO="$(has_repo x11)"
HAS_ROOT_REPO="$(has_repo root)"

case "$TERMUX_APP_PACKAGE_MANAGER" in
	apt)
		case "$CMD" in
			f*) dpkg -L "$@";;
			sh*|inf*) apt show "$@";;
			add|i*) select_mirror; update_apt_cache; apt install "$@";;
			autoc*) apt autoclean;;
			cl*) apt clean;;
			list-a*) apt list "$@";;
			list-i*) apt list --installed "$@";;
			rei*) apt install --reinstall "$@";;
			se*) select_mirror; update_apt_cache; apt search "$@";;
			un*|rem*|rm|del*) apt remove "$@";;
			upd*) select_mirror; apt update;;
			up|upg*) select_mirror; apt update; apt full-upgrade "$@";;
			*) ERROR=true;;
		esac;;
	pacman)
		case "$CMD" in
			f*) pacman -Ql "$@";;
			sh*|inf*) pacman -Qi "$@";;
			add|i*) pacman -Sy --needed "$@";;
			autoc*) pacman -Sc;;
			cl*) pacman -Scc;;
			list-a*) pacman -Sl "$@";;
			list-i*) pacman -Q "$@";;
			rei*) pacman -S "$@";;
			se*) pacman -Sys "$@";;
			un*|rem*|rm|del*) pacman -Rcns "$@";;
			upd*) pacman -Sy "$@";;
			up|upg*) pacman -Syu "$@";;
			*) ERROR=true;;
		esac;;
esac

if $ERROR; then
	echo "Unknown command: '$CMD' (run 'pkg help' for usage information)"; exit 1
fi
